---
apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: argocd
  namespace: argocd
spec:
  interval: 5m
  chart:
    spec:
      # renovate: registryUrl=https://argoproj.github.io/argo-helm/
      chart: argo-cd
      version: 5.32.1
      sourceRef:
        kind: HelmRepository
        name: argocd-charts
        namespace: flux-system
      interval: 5m
  values:
    global:
      image:
        # -- If defined, a repository applied to all Argo CD deployments
        repository: quay.io/argoproj/argocd
        # -- Overrides the global Argo CD image tag whose default is the chart appVersion
        tag: "v2.7.1"
        # -- If defined, a imagePullPolicy applied to all Argo CD deployments
        imagePullPolicy: IfNotPresent
      # -- Annotations for the all deployed pods
      podAnnotations: {}
      # -- Labels for the all deployed pods
      podLabels: {}
      # -- Toggle and define securityContext. See [values.yaml]
      securityContext: {}
      #  runAsUser: 999
      #  runAsGroup: 999
      #  fsGroup: 999
      networkPolicy:
        # -- Create NetworkPolicy objects for all components
        create: false
        # -- Default deny all ingress traffic
        defaultDenyIngress: false
    ## Controller
    controller:
      # -- Application controller name string
      name: application-controller

      image:
        # -- Repository to use for the application controller
        # @default -- `""` (defaults to global.image.repository)
        repository: ""
        # -- Tag to use for the application controller
        # @default -- `""` (defaults to global.image.tag)
        tag: ""
        # -- Image pull policy for the application controller
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: ""

      # -- The number of application controller pods to run.
      # If changing the number of replicas you must pass the number as `ARGOCD_CONTROLLER_REPLICAS` as an environment variable
      replicas: 1

      # -- Deploy the application controller as a StatefulSet instead of a Deployment, this is required for HA capability.
      enableStatefulSet: true

      ## Application controller commandline flags
      args:
        # -- define the application controller `--status-processors`
        statusProcessors: "20"
        # -- define the application controller `--operation-processors`
        operationProcessors: "10"
        # -- define the application controller `--app-resync`
        appResyncPeriod: "180"
        # -- define the application controller `--self-heal-timeout-seconds`
        selfHealTimeout: "5"
        # -- define the application controller `--repo-server-timeout-seconds`
        repoServerTimeoutSeconds: "60"

      # -- Application controller log format. Either `text` or `json`
      logFormat: text
      # -- Application controller log level
      logLevel: info
      # -- Application controller listening port
      containerPort: 8082

      ## Readiness and liveness probes for default backend
      ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
      ##
      readinessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 30
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      livenessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 30
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1

      # -- Additional volumeMounts to the application controller main container
      volumeMounts: []

      # -- Additional volumes to the application controller pod
      volumes: []

      ## Controller service configuration
      service:
        # -- Application controller service annotations
        annotations: {}
        # -- Application controller service labels
        labels: {}
        # -- Application controller service port
        port: 8082
        # -- Application controller service port name
        portName: https-controller

      # -- [Node selector]
      nodeSelector: {}
      # -- [Tolerations] for use with node taints
      tolerations: []
      # -- Assign custom [affinity] rules to the deployment
      affinity: {}

      # -- Assign custom [TopologySpreadConstraints] rules to the application controller
      ## Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
      ## If labelSelector is left out, it will default to the labelSelector configuration of the deployment
      topologySpreadConstraints: []
      # - maxSkew: 1
      #   topologyKey: topology.kubernetes.io/zone
      #   whenUnsatisfiable: DoNotSchedule

      # -- Priority class for the application controller pods
      priorityClassName: ""

      # -- Resource limits and requests for the application controller pods
      resources:
        requests:
          cpu: 150m
          memory: 250Mi
        limits:
          memory: 400MI


      serviceAccount:
        # -- Create a service account for the application controller
        create: true
        # -- Service account name
        name: argocd-application-controller
        # -- Annotations applied to created service account
        annotations: {}
        # -- Automount API credentials for the Service Account
        automountServiceAccountToken: true

      ## Application controller metrics configuration
      metrics:
        # -- Deploy metrics service
        enabled: true
        service:
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port
          servicePort: 8082
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: true
          # -- Prometheus ServiceMonitor interval
          interval: 60s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector: {}
          # prometheus: kube-prometheus

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: "" # "monitoring"
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}
        rules:
          # -- Deploy a PrometheusRule for the application controller
          enabled: true
          # -- PrometheusRule.Spec for the application controller
          spec:
            # - alert: ArgoAppMissing
            #   expr: |
            #     absent(argocd_app_info)
            #   for: 15m
            #   labels:
            #     severity: critical
            #   annotations:
            #     summary: "[Argo CD] No reported applications"
            #     description: >
            #       Argo CD has not reported any applications data for the past 15 minutes which
            #       means that it must be down or not functioning properly.  This needs to be
            #       resolved for this cloud to continue to maintain state.
            - alert: ArgoAppNotSynced
              expr: |
                argocd_app_info{sync_status!="Synced"} == 1
              for: 12h
              labels:
                severity: warning
              annotations:
                summary: "[{{`{{$labels.name}}`}}] Application not synchronized"
                description: >
                  The application [{{`{{$labels.name}}`}} has not been synchronized for over
                  12 hours which means that the state of this cloud has drifted away from the
                  state inside Git.
          selector:
            prometheus: kube-prometheus-stack
          namespace: monitoring
          additionalLabels: {}

      ## Enable if you would like to grant rights to Argo CD to deploy to the local Kubernetes cluster.
      clusterAdminAccess:
        # -- Enable RBAC for local cluster deployments
        enabled: true
      pdb:
        # -- Labels to be added to application controller pdb
        labels: {}
        # -- Annotations to be added to application controller pdb
        annotations: {}

        # -- Deploy a Poddisruptionbudget for the application controller
        enabled: false
        # minAvailable: 1
        # maxUnavailable: 0

      # -- Secrets with credentials to pull images from a private registry
      imagePullSecrets: []

    ## Dex
    dex:
      # -- Enable dex
      enabled: true
      # -- Dex name
      name: dex-server

      metrics:
        # -- Deploy metrics service
        enabled: false
        service:
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: false
          # -- Prometheus ServiceMonitor interval
          interval: 30s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector: {}
          # prometheus: kube-prometheus

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: "" # "monitoring"
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}

      image:
        # -- Dex image repository
        repository: ghcr.io/dexidp/dex
        # -- Dex image tag
        tag: v2.36.0
        # -- Dex imagePullPolicy
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: ""
      initImage:
        # -- Argo CD init image repository
        # @default -- `""` (defaults to global.image.repository)
        repository: ""
        # -- Argo CD init image tag
        # @default -- `""` (defaults to global.image.tag)
        tag: ""
        # -- Argo CD init image imagePullPolicy
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: ""
      ## Probes for Dex server
      ## Supported from Dex >= 2.28.0
      livenessProbe:
        # -- Enable Kubernetes liveness probe for Dex >= 2.28.0
        enabled: false
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 10
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      readinessProbe:
        # -- Enable Kubernetes readiness probe for Dex >= 2.28.0
        enabled: false
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 10
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1

      serviceAccount:
        # -- Create dex service account
        create: true
        # -- Dex service account name
        name: argocd-dex-server
        # -- Annotations applied to created service account
        annotations: {}
        # -- Automount API credentials for the Service Account
        automountServiceAccountToken: true

      # -- Additional volumeMounts to the dex main container
      volumeMounts:
        - name: static-files
          mountPath: /shared

      # -- Additional volumes to the dex pod
      volumes:
        - name: static-files
          emptyDir: {}
      # -- Container port for HTTP access
      containerPortHttp: 5556
      # -- Service port for HTTP access
      servicePortHttp: 5556
      # -- Service port name for HTTP access
      servicePortHttpName: http
      # -- Container port for gRPC access
      containerPortGrpc: 5557
      # -- Service port for gRPC access
      servicePortGrpc: 5557
      # -- Service port name for gRPC access
      servicePortGrpcName: grpc
      # -- Container port for metrics access
      containerPortMetrics: 5558
      # -- Service port for metrics access
      servicePortMetrics: 5558

      # -- Resource limits and requests for dex
      resources:
        requests:
          cpu: 5m
          memory: 32Mi
        limits:
          memory: 128Mi

      pdb:
        # -- Labels to be added to Dex server pdb
        labels: {}
        # -- Annotations to be added to Dex server pdb
        annotations: {}

        # -- Deploy a Poddisruptionbudget for the Dex server
        enabled: false
        # minAvailable: 1
        # maxUnavailable: 0

      # -- Secrets with credentials to pull images from a private registry
      imagePullSecrets: []

    ## Redis
    redis:
      # -- Enable redis
      enabled: true
      # -- Redis name
      name: redis

      image:
        # -- Redis repository
        repository: public.ecr.aws/docker/library/redis
        # -- Redis tag
        tag: 7.0.11-alpine
        # -- Redis imagePullPolicy
        imagePullPolicy: IfNotPresent

      # -- Additional command line arguments to pass to redis-server
      extraArgs: []
      # - --bind
      # - "0.0.0.0"

      # -- Redis container port
      containerPort: 6379
      # -- Redis service port
      servicePort: 6379
      # -- Redis pod-level security context
      securityContext:
        runAsNonRoot: true
        runAsUser: 999

      serviceAccount:
        # -- Create a service account for the redis pod
        create: false
        # -- Service account name for redis pod
        name: ""
        # -- Annotations applied to created service account
        annotations: {}
        # -- Automount API credentials for the Service Account
        automountServiceAccountToken: false

      # -- Resource limits and requests for redis
      resources:
        requests:
          cpu: 5m
          memory: 5Mi
        limits:
          memory: 64Mi
      service:
        # -- Redis service annotations
        annotations: {}
        # -- Additional redis service labels
        labels: {}

      metrics:
        # -- Deploy metrics service and redis-exporter sidecar
        enabled: false
        image:
          # -- redis-exporter image repository
          repository: public.ecr.aws/bitnami/redis-exporter
          # -- redis-exporter image tag
          tag: 1.39.0-debian-10-r2
          # -- redis-exporter image PullPolicy
          imagePullPolicy: IfNotPresent
        # -- Port to use for redis-exporter sidecar
        containerPort: 9121
        # -- Resource limits and requests for redis-exporter sidecar
        resources: {}
        # limits:
        #   cpu: 50m
        #   memory: 64Mi
        # requests:
        #   cpu: 10m
        #   memory: 32Mi
        service:
          # -- Metrics service type
          type: ClusterIP
          # -- Metrics service clusterIP. `None` makes a "headless service" (no virtual IP)
          clusterIP: None
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port
          servicePort: 9121
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: false
          # -- Interval at which metrics should be scraped
          interval: 30s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector: {}
          # prometheus: kube-prometheus

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: "" # "monitoring"
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}

      pdb:
        # -- Labels to be added to Redis server pdb
        labels: {}
        # -- Annotations to be added to Redis server pdb
        annotations: {}

        # -- Deploy a Poddisruptionbudget for the Redis server
        enabled: false
        # minAvailable: 1
        # maxUnavailable: 0

      # -- Secrets with credentials to pull images from a private registry
      imagePullSecrets: []


    # This key configures Redis-HA subchart and when enabled (redis-ha.enabled=true)
    # the custom redis deployment is omitted
    # Check the redis-ha chart for more properties
    redis-ha:
      # -- Enables the Redis HA subchart and disables the custom Redis single node deployment
      enabled: false
    ## Server
    server:
      # -- Argo CD server name
      name: argo-cd-server
      # -- The number of server pods to run
      replicas: 1

      autoscaling:
        # -- Enable Horizontal Pod Autoscaler ([HPA]) for the Argo CD server
        enabled: false
        # -- Minimum number of replicas for the Argo CD server [HPA]
        minReplicas: 1
        # -- Maximum number of replicas for the Argo CD server [HPA]
        maxReplicas: 5
        # -- Average CPU utilization percentage for the Argo CD server [HPA]
        targetCPUUtilizationPercentage: 50
        # -- Average memory utilization percentage for the Argo CD server [HPA]
        targetMemoryUtilizationPercentage: 50
      image:
        # -- Repository to use for the Argo CD server
        # @default -- `""` (defaults to global.image.repository)
        repository: "" # defaults to global.image.repository
        # -- Tag to use for the Argo CD server
        # @default -- `""` (defaults to global.image.tag)
        tag: "" # defaults to global.image.tag
        # -- Image pull policy for the Argo CD server
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: "" # IfNotPresent

      # -- Additional command line arguments to pass to Argo CD server
      extraArgs: []
      #  - --insecure

      # This flag is used to either remove or pass the CLI flag --staticassets /shared/app to the Argo CD server app
      staticAssets:
        # -- Disable deprecated flag `--staticassets`
        enabled: true
      # -- Argo CD server log format: Either `text` or `json`
      logFormat: text
      # -- Argo CD server log level
      logLevel: info
      # -- Configures the server port
      containerPort: 8080

      ## Readiness and liveness probes for default backend
      ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
      ##
      readinessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 10
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      livenessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 10
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      # -- Resource limits and requests for the Argo CD server
      resources:
        requests:
          cpu: 7m
          memory: 32Mi
        limits:
          memory: 128Mi

      ## Certificate configuration
      certificate:
        # -- Deploy a Certificate resource (requires cert-manager)
        enabled: true
        # -- Certificate primary domain (commonName)
        domain: "argocd.${SECRET_DOMAIN}"
        # -- The requested 'duration' (i.e. lifetime) of the Certificate. Value must be in units accepted by Go time.ParseDuration
        duration: "2160h"
        # -- How long before the currently issued certificate's expiry cert-manager should renew the certificate. Value must be in units accepted by Go time.ParseDuration
        renewBefore: "336h"
        issuer:
          # -- Certificate issuer group. Set if using an external issuer. Eg. `cert-manager.io`
          group: "cert-manager.io"
          # -- Certificate issuer kind. Either `Issuer` or `ClusterIssuer`
          kind: "ClusterIssuer"
          # -- Certificate isser name. Eg. `letsencrypt`
          name: "letsencrypt-production"
        # -- The name of the Secret that will be automatically created and managed by this Certificate resource
        secretName: argocd-server-tls

      ## Server service configuration
      service:
        # -- Server service annotations
        annotations: {}
        # -- Server service labels
        labels: {}
        # -- Server service type
        type: ClusterIP
        # -- Server service http port for NodePort service type (only if `server.service.type` is set to "NodePort")
        nodePortHttp: 30080
        # -- Server service https port for NodePort service type (only if `server.service.type` is set to "NodePort")
        nodePortHttps: 30443
        # -- Server service http port
        servicePortHttp: 80
        # -- Server service https port
        servicePortHttps: 443
        # -- Server service http port name, can be used to route traffic via istio
        servicePortHttpName: http
        # -- Server service https port name, can be used to route traffic via istio
        servicePortHttpsName: https
        # -- Use named target port for argocd
        ## Named target ports are not supported by GCE health checks, so when deploying argocd on GKE
        ## and exposing it via GCE ingress, the health checks fail and the load balancer returns a 502.
        namedTargetPort: true
        # -- LoadBalancer will get created with the IP specified in this field
        loadBalancerIP: ""
        # -- Source IP ranges to allow access to service from
        loadBalancerSourceRanges: []
        # -- Server service external IPs
        externalIPs: []
        # -- Denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints
        externalTrafficPolicy: ""
        # -- Used to maintain session affinity. Supports `ClientIP` and `None`
        sessionAffinity: ""

      ## Server metrics service configuration
      metrics:
        # -- Deploy metrics service
        enabled: true
        service:
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port
          servicePort: 8083
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: false
          # -- Prometheus ServiceMonitor interval
          interval: 30s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector:
            prometheus: kube-prometheus-stack

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: ""  # monitoring
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}

      serviceAccount:
        # -- Create server service account
        create: true
        # -- Server service account name
        name: argocd-server
        # -- Annotations applied to created service account
        annotations: {}
        # -- Automount API credentials for the Service Account
        automountServiceAccountToken: true

      ingress:
        # -- Enable an ingress resource for the Argo CD server
        enabled: true
        ingressClassName: "traefik"
        annotations:
          cert-manager.io/cluster-issuer: "letsencrypt-production"        
          hajimari.io/enable: "true"
          hajimari.io/icon: "sitemap"
          hajimari.io/appName: "argocd"
          traefik.ingress.kubernetes.io/router.entrypoints: "websecure"
        hosts:
          - "argocd.${SECRET_DOMAIN}"
        # -- List of ingress paths
        paths:
          - /
        # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
        pathType: Prefix
        tls:
          - hosts:
              - "argocd.${SECRET_DOMAIN}"
            secretName: "argocd-tls-secret"
        # -- Uses `server.service.servicePortHttps` instead `server.service.servicePortHttp`
        https: true
      # -- Manage Argo CD configmap (Declarative Setup)
      ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
      configEnabled: true
      # -- [General Argo CD configuration]
      # @default -- See [values.yaml]
      config:
        kustomize.buildOptions: "--enable-alpha-plugins"
        # Argo CD's externally facing base URL (optional). Required when configuring SSO
        url: ""
        # Argo CD instance label key
        application.instanceLabelKey: argocd.argoproj.io/instance

        # Enable logs RBAC enforcement
        # Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/upgrading/2.3-2.4/#enable-logs-rbac-enforcement
        server.rbac.log.enforce.enable: "false"

        # exec.enabled indicates whether the UI exec feature is enabled. It is disabled by default.
        # Ref: https://argo-cd.readthedocs.io/en/latest/operator-manual/rbac/#exec-resource
        exec.enabled: "false"
        # admin.enabled indicates whether the admin user is enabled. It is enabled by default.
        # https://argo-cd.readthedocs.io/en/latest/faq/#how-to-disable-admin-user
        admin.enabled: "true"

        # dex.config: |
        #   connectors:
        #     # GitHub example
        #     - type: github
        #       id: github
        #       name: GitHub
        #       config:
        #         clientID: aabbccddeeff00112233
        #         clientSecret: $dex.github.clientSecret # Alternatively $<some_K8S_secret>:dex.github.clientSecret
        #         orgs:
        #         - name: your-github-org

        # oidc.config: |
        #   name: AzureAD
        #   issuer: https://login.microsoftonline.com/TENANT_ID/v2.0
        #   clientID: CLIENT_ID
        #   clientSecret: $oidc.azuread.clientSecret
        #   requestedIDTokenClaims:
        #     groups:
        #       essential: true
        #   requestedScopes:
        #     - openid
        #     - profile
        #     - email

      # -- Annotations to be added to Argo CD ConfigMap
      configAnnotations: {}

      # -- Argo CD rbac config ([Argo CD RBAC policy])
      ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/rbac.md
      rbacConfig:
        {}
        # policy.csv is a file containing user-defined RBAC policies and role definitions (optional).
        # Policy rules are in the form:
        #   p, subject, resource, action, object, effect
        # Role definitions and bindings are in the form:
        #   g, subject, inherited-subject
        # See https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/rbac.md for additional information.
        # policy.csv: |
        #   # Grant all members of the group 'my-org:team-alpha; the ability to sync apps in 'my-project'
        #   p, my-org:team-alpha, applications, sync, my-project/*, allow
        #   # Grant all members of 'my-org:team-beta' admins
        #   g, my-org:team-beta, role:admin
        # policy.default is the name of the default role which Argo CD will falls back to, when
        # authorizing API requests (optional). If omitted or empty, users may be still be able to login,
        # but will see no apps, projects, etc...
        # policy.default: role:readonly
        # scopes controls which OIDC scopes to examine during rbac enforcement (in addition to `sub` scope).
        # If omitted, defaults to: '[groups]'. The scope value can be a string, or a list of strings.
        # scopes: '[cognito:groups, email]'

      # -- Annotations to be added to Argo CD rbac ConfigMap
      rbacConfigAnnotations: {}

      # -- Whether or not to create the configmap. If false, it is expected the configmap will be created
      # by something else. Argo CD will not work if there is no configMap created with the name above.
      rbacConfigCreate: true

      # -- Deploy Argo CD Applications within this helm release
      # @default -- `[]` (See [values.yaml])
      ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/
      additionalApplications: []
      # - name: guestbook
      #   namespace: argocd
      #   additionalLabels: {}
      #   additionalAnnotations: {}
      #   finalizers:
      #   - resources-finalizer.argocd.argoproj.io
      #   project: guestbook
      #   source:
      #     repoURL: https://github.com/argoproj/argocd-example-apps.git
      #     targetRevision: HEAD
      #     path: guestbook
      #     directory:
      #       recurse: true
      #   destination:
      #     server: https://kubernetes.default.svc
      #     namespace: guestbook
      #   syncPolicy:
      #     automated:
      #       prune: false
      #       selfHeal: false
      #   ignoreDifferences:
      #   - group: apps
      #     kind: Deployment
      #     jsonPointers:
      #     - /spec/replicas
      #   info:
      #   - name: url
      #     value: https://argoproj.github.io/

      # -- Deploy Argo CD Projects within this helm release
      # @default -- `[]` (See [values.yaml])
      ## Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/
      additionalProjects: []
      # - name: guestbook
      #   namespace: argocd
      #   additionalLabels: {}
      #   additionalAnnotations: {}
      #   finalizers:
      #   - resources-finalizer.argocd.argoproj.io
      #   description: Example Project
      #   sourceRepos:
      #   - '*'
      #   destinations:
      #   - namespace: guestbook
      #     server: https://kubernetes.default.svc
      #   clusterResourceWhitelist: []
      #   clusterResourceBlacklist: []
      #   namespaceResourceBlacklist:
      #   - group: ''
      #     kind: ResourceQuota
      #   - group: ''
      #     kind: LimitRange
      #   - group: ''
      #     kind: NetworkPolicy
      #     orphanedResources: {}
      #     roles: []
      #   namespaceResourceWhitelist:
      #   - group: 'apps'
      #     kind: Deployment
      #   - group: 'apps'
      #     kind: StatefulSet
      #   orphanedResources: {}
      #   roles: []
      #   syncWindows:
      #   - kind: allow
      #     schedule: '10 1 * * *'
      #     duration: 1h
      #     applications:
      #     - '*-prod'
      #     manualSync: true
      #   signatureKeys:
      #   - keyID: ABCDEF1234567890

      ## Enable Admin ClusterRole resources.
      ## Enable if you would like to grant rights to Argo CD to deploy to the local Kubernetes cluster.
      clusterAdminAccess:
        # -- Enable RBAC for local cluster deployments
        enabled: true
      extensions:
        # -- Enable support for extensions
        ## This function in tech preview stage, do expect unstability or breaking changes in newer versions. Bump image.tag if necessary.
        enabled: false
      pdb:
        # -- Labels to be added to server pdb
        labels: {}
        # -- Annotations to be added to server pdb
        annotations: {}

        # -- Deploy a Poddisruptionbudget for the server
        enabled: false
        # minAvailable: 1
        # maxUnavailable: 0

      # -- Secrets with credentials to pull images from a private registry
      imagePullSecrets: []

    ## Repo Server
    repoServer:
      # -- Repo server name
      name: repo-server
      # -- The number of repo server pods to run
      replicas: 1
      autoscaling:
        # -- Enable Horizontal Pod Autoscaler ([HPA]) for the repo server
        enabled: false
        # -- Minimum number of replicas for the repo server [HPA]
        minReplicas: 1
        # -- Maximum number of replicas for the repo server [HPA]
        maxReplicas: 5
        # -- Average CPU utilization percentage for the repo server [HPA]
        targetCPUUtilizationPercentage: 50
        # -- Average memory utilization percentage for the repo server [HPA]
        targetMemoryUtilizationPercentage: 50
      image:
        # -- Repository to use for the repo server
        # @default -- `""` (defaults to global.image.repository)
        repository: "" # defaults to global.image.repository
        # -- Tag to use for the repo server
        # @default -- `""` (defaults to global.image.tag)
        tag: "" # defaults to global.image.tag
        # -- Image pull policy for the repo server
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: "" # IfNotPresent

      ##### KSOPS CONFIGURATION #####
      # Set the XDG_CONFIG_HOME env variable to allow kustomize to detect the plugin
      env:
        - name: GNUPGHOME
          value: /home/argocd/.gnupg
        - name: XDG_CONFIG_HOME
          value: /.config
      # Use init containers to configure custom tooling
      # https://argoproj.github.io/argo-cd/operator-manual/custom_tools/
      volumes:
        - name: custom-tools
          emptyDir: {}
        - name: gnupg-home
          emptyDir: {}
        - name: deploy-gpg-key
          secret:
            secretName: sops-gpg
      initContainers:
        - name: import-gpg-key
          image: argoproj/argocd:v2.6.7
          command: ["gpg", "--import", "/deploy-gpg-key/sops.asc"]
          env:
            - name: GNUPGHOME
              value: /gnupg-home/.gnupg
          volumeMounts:
            - mountPath: /deploy-gpg-key
              name: deploy-gpg-key
              readOnly: true
            - mountPath: /gnupg-home
              name: gnupg-home      
        - name: install-ksops
          image: viaductoss/ksops:v4.1.1-arm64
          command: ["/bin/sh", "-c"]
          args:
            - echo "Installing KSOPS...";
              mv ksops /custom-tools/;
              mv $GOPATH/bin/kustomize /custom-tools/;
              echo "Done.";
          volumeMounts:
            - mountPath: /custom-tools
              name: custom-tools
      volumeMounts:
        - mountPath: /home/argocd/.gnupg
          name: gnupg-home
          subPath: .gnupg
        # - name: gpg-private-key
        #   mountPath: /app/config/gpg
        - mountPath: /usr/local/bin/kustomize
          name: custom-tools
          subPath: kustomize
          # Verify this matches a XDG_CONFIG_HOME=/.config env variable
        - mountPath: /.config/kustomize/plugin/viaduct.ai/v1/ksops/ksops
          name: custom-tools
          subPath: ksops          
      ##############################
      # -- Repo server log format: Either `text` or `json`
      logFormat: text
      # -- Repo server log level
      logLevel: info
      # -- Configures the repo server port
      containerPort: 8081

      ## Readiness and liveness probes for default backend
      ## Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/
      ##
      readinessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 30
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      livenessProbe:
        # -- Minimum consecutive failures for the [probe] to be considered failed after having succeeded
        failureThreshold: 3
        # -- Number of seconds after the container has started before [probe] is initiated
        initialDelaySeconds: 10
        # -- How often (in seconds) to perform the [probe]
        periodSeconds: 10
        # -- Minimum consecutive successes for the [probe] to be considered successful after having failed
        successThreshold: 1
        # -- Number of seconds after which the [probe] times out
        timeoutSeconds: 1
      # -- Resource limits and requests for the repo server pods
      resources:
        requests:
          cpu: 25m
          memory: 50Mi
        limits:
          memory: 128Mi
      ## Repo server service configuration
      service:
        # -- Repo server service annotations
        annotations: {}
        # -- Repo server service labels
        labels: {}
        # -- Repo server service port
        port: 8081
        # -- Repo server service port name
        portName: https-repo-server

      ## Repo server metrics service configuration
      metrics:
        # -- Deploy metrics service
        enabled: false
        service:
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port
          servicePort: 8084
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: false
          # -- Prometheus ServiceMonitor interval
          interval: 30s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector: {}
          # prometheus: kube-prometheus

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: "" # "monitoring"
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}

      ## Enable Admin ClusterRole resources.
      ## Enable if you would like to grant cluster rights to Argo CD repo server.
      clusterAdminAccess:
        # -- Enable RBAC for local cluster deployments
        enabled: false
      ## Enable Custom Rules for the Repo server's Cluster Role resource
      ## Enable this and set the rules: to whatever custom rules you want for the Cluster Role resource.
      ## Defaults to off
      clusterRoleRules:
        # -- Enable custom rules for the Repo server's Cluster Role resource
        enabled: false
        # -- List of custom rules for the Repo server's Cluster Role resource
        rules: []

      ## Repo server service account
      ## If create is set to true, make sure to uncomment the name and update the rbac section below
      serviceAccount:
        # -- Create repo server service account
        create: true
        # -- Repo server service account name
        name: "argocd-repo-server"
        # -- Annotations applied to created service account
        annotations: {}
        # -- Automount API credentials for the Service Account
        automountServiceAccountToken: true

        # rbac permssions
      rbac:
      - apiGroups:
        - ""
        resources:
        - secrets
        verbs:
        - get
      # Init container to copy argocd binary
      copyutil:
        # -- Resource limits and requests for the copyutil initContainer
        resources: {}
        #  limits:
        #    cpu: 50m
        #    memory: 64Mi
        #  requests:
        #    cpu: 10m
        #    memory: 32Mi
      pdb:
        # -- Labels to be added to Repo server pdb
        labels: {}
        # -- Annotations to be added to Repo server pdb
        annotations: {}

        # -- Deploy a Poddisruptionbudget for the Repo server
        enabled: false
        # minAvailable: 1
        # maxUnavailable: 0

      # -- Secrets with credentials to pull images from a private registry
      imagePullSecrets: []

    ## Argo Configs
    configs:
      # -- Known Hosts configmap annotations
      knownHostsAnnotations: {}
      knownHosts:
        data:
          # -- Known Hosts
          # @default -- See [values.yaml]
          ssh_known_hosts: |
            bitbucket.org ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAubiN81eDcafrgMeLzaFPsw2kNvEcqTKl/VqLat/MaB33pZy0y3rJZtnqwR2qOOvbwKZYKiEO1O6VqNEBxKvJJelCq0dTXWT5pbO2gDXC6h6QDXCaHo6pOHGPUy+YBaGQRGuSusMEASYiWunYN0vCAI8QaXnWMXNMdFP3jHAJH0eDsoiGnLPBlBp4TNm6rYI74nMzgz3B9IikW4WVK+dc8KZJZWYjAuORU3jc1c/NPskD2ASinf8v3xnfXeukU0sJ5N6m5E8VLjObPEO+mN2t/FZTMZLiFqPWc/ALSqnMnnhwrNi2rbfg/rd/IpL8Le3pSBne8+seeFVBoGqzHM9yXw==
            github.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBEmKSENjQEezOmxkZMy7opKgwFB9nkt5YRrYMjNuG5N87uRgg6CLrbo5wAdT/y6v0mKV0U2w0WZ2YB/++Tpockg=
            github.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOMqqnkVzrm0SdG6UOoqKLsabgH5C9okWi0dh2l9GKJl
            github.com ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAq2A7hRGmdnm9tUDbO9IDSwBK6TbQa+PXYPCPy6rbTrTtw7PHkccKrpp0yVhp5HdEIcKr6pLlVDBfOLX9QUsyCOV0wzfjIJNlGEYsdlLJizHhbn2mUjvSAHQqZETYP81eFzLQNnPHt4EVVUh7VfDESU84KezmD5QlWpXLmvU31/yMf+Se8xhHTvKSCZIFImWwoG6mbUoWf9nzpIoaSjB+weqqUUmpaaasXVal72J+UX2B+2RPW3RcT0eOzQgqlJL3RKrTJvdsjE3JEAvGq3lGHSZXy28G3skua2SmVi/w4yCE6gbODqnTWlg7+wC604ydGXA8VJiS5ap43JXiUFFAaQ==
            gitlab.com ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFSMqzJeV9rUzU4kWitGjeR4PWSa29SPqJ1fVkhtj3Hw9xjLVXVYrU9QlYWrOLXBpQ6KWjbjTDTdDkoohFzgbEY=
            gitlab.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIAfuCHKVTjquxvt6CM6tdG4SLp1Btn/nOeHHE5UOzRdf
            gitlab.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCsj2bNKTBSpIYDEGk9KxsGh3mySTRgMtXL583qmBpzeQ+jqCMRgBqB98u3z++J1sKlXHWfM9dyhSevkMwSbhoR8XIq/U0tCNyokEi/ueaBMCvbcTHhO7FcwzY92WK4Yt0aGROY5qX2UKSeOvuP4D6TPqKF1onrSzH9bx9XUf2lEdWT/ia1NEKjunUqu1xOB/StKDHMoX4/OKyIzuS0q/T1zOATthvasJFoPrAjkohTyaDUz2LN5JoH839hViyEG82yB+MjcFV5MU3N1l1QL3cVUCh93xSaua1N85qivl+siMkPGbO5xR/En4iEY6K2XPASUEMaieWVNTRCtJ4S8H+9
            ssh.dev.azure.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
            vs-ssh.visualstudio.com ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7Hr1oTWqNqOlzGJOfGJ4NakVyIzf1rXYd4d7wo6jBlkLvCA4odBlL0mDUyZ0/QUfTTqeu+tm22gOsv+VrVTMk6vwRU75gY/y9ut5Mb3bR5BV58dKXyq9A9UeB5Cakehn5Zgm6x1mKoVyf+FFn26iYqXJRgzIZZcZ5V6hrE0Qg39kZm4az48o0AUbf6Sp4SLdvnuMa2sVNwHBboS7EJkm57XQPVU3/QpyNLHbWDdzwtrlS+ez30S3AdYhLKEOxAG8weOnyrtLJAUen9mTkol8oII1edf7mWWbWVf0nBmly21+nZcmCTISQBtdcyPaEno7fFQMDD26/s0lfKob4Kw8H
      secret:
        # -- Create the argocd-secret
        createSecret: true
    openshift:
      # -- enables using arbitrary uid for argo repo server
      enabled: false

    applicationSet:
      # -- Enable Application Set controller
      enabled: true

      # -- Application Set controller name string
      name: applicationset-controller

      # -- The number of controller pods to run
      replicaCount: 1

      image:
        # -- Repository to use for the application set controller
        # @default -- `""` (defaults to global.image.repository)
        repository: ""
        # -- Tag to use for the application set controller
        # @default -- `""` (defaults to global.image.tag)
        tag: ""
        # -- Image pull policy for the application set controller
        # @default -- `""` (defaults to global.image.imagePullPolicy)
        imagePullPolicy: ""

      args:
        # -- The default metric address
        metricsAddr: :8080
        # -- The default health check port
        probeBindAddr: :8081
        # -- The default leader election setting
        enableLeaderElection: false
        # -- How application is synced between the generator and the cluster
        policy: sync
        # -- Print debug logs
        debug: false
        # -- Enable dry run mode
        dryRun: false

      ## Metrics service configuration
      metrics:
        # -- Deploy metrics service
        enabled: false
        service:
          # -- Metrics service annotations
          annotations: {}
          # -- Metrics service labels
          labels: {}
          # -- Metrics service port
          servicePort: 8085
          # -- Metrics service port name
          portName: http-metrics
        serviceMonitor:
          # -- Enable a prometheus ServiceMonitor
          enabled: false
          # -- Prometheus ServiceMonitor interval
          interval: 30s
          # -- Prometheus [RelabelConfigs] to apply to samples before scraping
          relabelings: []
          # -- Prometheus [MetricRelabelConfigs] to apply to samples before ingestion
          metricRelabelings: []
          # -- Prometheus ServiceMonitor selector
          selector: {}
          # prometheus: kube-prometheus

          # -- Prometheus ServiceMonitor scheme
          scheme: ""
          # -- Prometheus ServiceMonitor tlsConfig
          tlsConfig: {}
          # -- Prometheus ServiceMonitor namespace
          namespace: ""  # monitoring
          # -- Prometheus ServiceMonitor labels
          additionalLabels: {}

      ## Application set service configuration
      service:
        # -- Application set service annotations
        annotations: {}
        # -- Application set service labels
        labels: {}
        # -- Application set service port
        port: 7000
        # -- Application set service port name
        portName: webhook

      serviceAccount:
        # -- Specifies whether a service account should be created
        create: true
        # -- Annotations to add to the service account
        annotations: {}
        # -- The name of the service account to use.
        # If not set and create is true, a name is generated using the fullname template
        name: ""

      # -- Resource limits and requests for the controller pods.
      resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
        requests:
          cpu: 5m
          memory: 40Mi
        limits:
          memory: 80Mi

      # -- [Node selector]
      nodeSelector: {}

      # -- [Tolerations] for use with node taints
      tolerations: []

      # -- Assign custom [affinity] rules
      affinity: {}

      # -- If specified, indicates the pod's priority. If not specified, the pod priority will be default or zero if there is no default.
      priorityClassName: ""

      # -- List of extra mounts to add (normally used with extraVolumes)
      extraVolumeMounts: []
      # - mountPath: /tmp/foobar
      #   name: foobar

      # -- List of extra volumes to add
      extraVolumes: []
      # - name: foobar
      #   emptyDir: {}

      # -- List of extra cli args to add
      extraArgs: []
      # - --loglevel=warn

      # -- Environment variables to pass to the controller
      extraEnv: []
      # - name: "MY_VAR"
      #   value: "value"

      # -- envFrom to pass to the controller
      # @default -- `[]` (See [values.yaml])
      extraEnvFrom: []
      # - configMapRef:
      #     name: config-map-name
      # - secretRef:
      #     name: secret-name

      ## Webhook for the Git Generator
      ## Ref: https://argocd-applicationset.readthedocs.io/en/master/Generators-Git/#webhook-configuration)
      webhook:
        ingress:
          # -- Enable an ingress resource for Webhooks
          enabled: false
          # -- Additional ingress annotations
          annotations: {}
          # -- Additional ingress labels
          labels: {}
          # -- Defines which ingress controller will implement the resource
          ingressClassName: ""

          # -- List of ingress hosts
          ## Hostnames must be provided if Ingress is enabled.
          ## Secrets must be manually created in the namespace
          hosts: []
          # - argocd-applicationset.example.com

          # -- List of ingress paths
          paths:
            - /api/webhook
          # -- Ingress path type. One of `Exact`, `Prefix` or `ImplementationSpecific`
          pathType: Prefix
          # -- Additional ingress paths
          extraPaths: []
          # - path: /*
          #   backend:
          #     serviceName: ssl-redirect
          #     servicePort: use-annotation
          ## for Kubernetes >=1.19 (when "networking.k8s.io/v1" is used)
          # - path: /*
          #   pathType: Prefix
          #   backend:
          #     service:
          #       name: ssl-redirect
          #       port:
          #         name: use-annotation

          # -- Ingress TLS configuration
          tls: []
          # - secretName: argocd-applicationset-tls
          #   hosts:
          #     - argocd-applicationset.example.com

    notifications:
      # -- Enable Notifications controller
      enabled: false
